resolver kube-dns.kube-system ipv6=off;

map $http_accept_language $accept_language {
    default en;
%{for lang in ingress.langs~}
    ~*^${lang} ${lang};
%{endfor~}
}

map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

%{if ingress.mtls~}
map $ssl_client_s_dn $ssl_client_s_dn_cn {
    default "";
    ~CN=(?<CN>[^,/]+) $CN;
}
%{endif~}

%{if ingress.mtls~}
# Check if the $http_x_certificate_client_cn header is present and the common name is in the list of
# trusted cns. If so, it uses that value; otherwise, it defaults to the Cn from the SSL certificate
map "$http_x_certificate_client_cn|$ssl_client_s_dn_cn" $client_cn {
    default                                $ssl_client_s_dn_cn;
%{if can(coalesce(cn_regex_pattern))~}
    ~^(.+)\|(${cn_regex_pattern})$   $http_x_certificate_client_cn;
%{endif~}
}

# Check if the $http_x_certificate_client_fingerprint header is present and the common name is in the list of
# trusted cns. If so, it uses that value; otherwise, it defaults to the Fingerprint from the SSL certificate
map "$http_x_certificate_client_fingerprint|$ssl_client_s_dn_cn" $client_fingerprint {
    default                                $ssl_client_fingerprint;
%{if can(coalesce(cn_regex_pattern))~}
    ~^(.+)\|(${cn_regex_pattern})$   $http_x_certificate_client_fingerprint;
%{endif~}
}
%{endif~}

upstream armonik {
    server ${ingress.underlying_endpoint.ip}:${ingress.underlying_endpoint.port} resolve;
    keepalive 128;
    keepalive_time 8h;
    keepalive_timeout 1h;
}

server {
%{if ingress.tls~}
    listen 8443 ssl http2;
    listen [::]:8443 ssl http2;
    listen 9443 ssl http2;
    listen [::]:9443 ssl http2;
    ssl_certificate     /ingress/ingress.crt;
    ssl_certificate_key /ingress/ingress.key;
%{if ingress.mtls~}
    ssl_verify_client on;
    ssl_client_certificate /ingressclient/ca.pem;
%{else~}
    ssl_verify_client off;
    proxy_hide_header X-Certificate-Client-CN;
    proxy_hide_header X-Certificate-Client-Fingerprint;
%{endif~}
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers EECDH+AESGCM:EECDH+AES256;
    ssl_conf_command Ciphersuites TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256;
%{else~}
    listen 8080;
    listen [::]:8080;
    listen 9080 http2;
    listen [::]:9080 http2;
%{endif~}

    sendfile on;
    tcp_nopush on;

    location = / {
        rewrite ^ $scheme://$http_host/admin/$accept_language/;
    }

    location = /admin {
        rewrite ^ $scheme://$http_host/admin/$accept_language/;
    }
    location = /admin/ {
        rewrite ^ $scheme://$http_host/admin/$accept_language/;
    }
%{for lang in ingress.langs~}
    location = /admin/${lang} {
        rewrite ^ $scheme://$http_host/admin/${lang}/;
    }
%{endfor~}
%{if can(try(coalesce(services_urls.admin_gui)))~}
    set $admin_app_upstream ${services_urls.admin_gui};
    location /admin/ {
        proxy_pass $admin_app_upstream$uri$is_args$args;
    }
%{endif~}
    location ~* ^/armonik\. {
%{if ingress.mtls~}
        grpc_set_header X-Certificate-Client-CN $client_cn ;
        grpc_set_header X-Certificate-Client-Fingerprint $client_fingerprint;
%{endif~}
%{if length(ingress.cors.allowed_host) != 0~}
        add_header Access-Control-Allow-Origin ${ingress.cors.allowed_host} always;
        add_header Access-Control-Allow-Methods ${join(",", ingress.cors.allowed_methods)} always;
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin ${ingress.cors.allowed_host} always;
            add_header Access-Control-Allow-Methods ${join(",", ingress.cors.allowed_methods)};
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Headers' ${join(",", setunion(cors.default_grpc_headers, cors_all_headers))};
            add_header 'Access-Control-Max-Age' ${ingress.cors.preflight_max_age};
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }
%{endif~}
        grpc_pass grpc://armonik;

        # Apparently, multiple chunks in a grpc stream is counted has a single body
        # So disable the limit
        client_max_body_size 0;

        # add a timeout of 1 month to avoid grpc exception for long task
        # TODO: find better configuration
        client_body_timeout 1d;
        proxy_read_timeout 30d;
        proxy_send_timeout 1d;
        grpc_read_timeout 30d;
        grpc_send_timeout 1d;
    }

    location /static/ {
%{if length(ingress.cors.allowed_host) != 0~}
        add_header Access-Control-Allow-Origin ${ingress.cors.allowed_host} always;
        add_header Access-Control-Allow-Methods ${join(",", ingress.cors.allowed_methods)} always;
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin ${ingress.cors.allowed_host} always;
            add_header Access-Control-Allow-Methods ${join(",", ingress.cors.allowed_methods)};
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Headers' ${join(",", cors_all_headers)};
            add_header 'Access-Control-Max-Age' ${ingress.cors.preflight_max_age};
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }
%{endif~}
        alias /static/;
    }


    proxy_buffering off;
    proxy_request_buffering off;

%{if can(try(coalesce(shared_storage))) && shared_storage.type == "s3"~}
 set $minio_upstream ${shared_storage.urls.service};
 location / {
    client_max_body_size 0;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    proxy_connect_timeout 300;
    # Default is HTTP/1, keepalive is only enabled in HTTP/1.1
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    chunked_transfer_encoding off;

    proxy_pass $minio_upstream$uri$is_args$args; # This uses the upstream directive definition to load balance
 }

 set $minioconsole_upstream ${shared_storage.urls.console};
 location /minioconsole {
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-NginX-Proxy true;

    rewrite ^/minioconsole/(.*) /$1 break;
    sub_filter '<head>' '<head><base href="$${scheme}://$${http_host}/minioconsole/">';
    sub_filter_once on;

    # This is necessary to pass the correct IP to be hashed
    real_ip_header X-Real-IP;

    proxy_connect_timeout 300;

    # To support websockets in MinIO versions released after January 2023
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    chunked_transfer_encoding off;

    proxy_pass $minioconsole_upstream$uri$is_args$args; # This uses the upstream directive definition to load balance and assumes a static Console port of 9001
 }
 %{endif~}


%{if can(try(coalesce(services_urls.seq)))~}
    set $seq_upstream ${services_urls.seq};
    location = /seq {
        rewrite ^ $scheme://$http_host/seq/ permanent;
    }
    location /seq/ {
%{if ingress.mtls~}
        proxy_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        proxy_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{endif~}
        proxy_set_header Host $http_host;
        proxy_set_header Accept-Encoding "";
        rewrite  ^/seq/(.*)  /$1 break;
        proxy_pass $seq_upstream$uri$is_args$args;
        sub_filter '<head>' '<head><base href="$${scheme}://$${http_host}/seq/">';
        sub_filter_once on;
        proxy_hide_header content-security-policy;
    }
%{endif~}
%{if can(try(coalesce(services_urls.grafana)))~}
    set $grafana_upstream ${services_urls.grafana};
    location = /grafana {
        rewrite ^ $scheme://$http_host/grafana/ permanent;
    }
    location /grafana/ {
        rewrite  ^/grafana/(.*)  /$1 break;
%{if ingress.mtls~}
        proxy_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        proxy_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{endif~}
        proxy_set_header Host $http_host;
        proxy_pass $grafana_upstream$uri$is_args$args;
        sub_filter '<head>' '<head><base href="$${scheme}://$${http_host}/grafana/">';
        sub_filter_once on;
        proxy_intercept_errors on;
        error_page 301 302 307 =302 $${scheme}://$${http_host}$${upstream_http_location};
    }
    location /grafana/api/live {
        rewrite  ^/grafana/(.*)  /$1 break;
%{if ingress.mtls~}
        proxy_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        proxy_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{endif~}
%{if ingress.tls~}
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
%{endif~}
        proxy_http_version 1.1;
        proxy_set_header Host $http_host;
        proxy_pass $grafana_upstream$uri$is_args$args;
    }
%{endif~}
}
