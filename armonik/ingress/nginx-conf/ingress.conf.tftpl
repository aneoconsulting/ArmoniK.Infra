resolver kube-dns.kube-system ipv6=off;

map $http_accept_language $accept_language {
    default en;
%{for lang in try(coalesce(gui.langs), {})~}
    ~*^${lang} ${lang};
%{endfor~}
}

map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

%{if mtls~}
map $ssl_client_s_dn $ssl_client_s_dn_cn {
    default "";
    ~CN=(?<CN>[^,/]+) $CN;
}
%{endif~}


%{if mtls~}
# Check if the $http_x_certificate_client_cn header is present and the common name is in the list of
# trusted cns. If so, it uses that value; otherwise, it defaults to the Cn from the SSL certificate
map "$http_x_certificate_client_cn|$ssl_client_s_dn_cn" $client_cn {
    default                                $ssl_client_s_dn_cn;
%{if can(coalesce(cn_regex_pattern))~}
    ~^(.+)\|(${cn_regex_pattern})$   $http_x_certificate_client_cn;
%{endif~}
}

# Check if the $http_x_certificate_client_fingerprint header is present and the common name is in the list of
# trusted cns. If so, it uses that value; otherwise, it defaults to the Fingerprint from the SSL certificate
map "$http_x_certificate_client_fingerprint|$ssl_client_s_dn_cn" $client_fingerprint {
    default                                $ssl_client_fingerprint;
%{if can(coalesce(cn_regex_pattern))~}
    ~^(.+)\|(${cn_regex_pattern})$   $http_x_certificate_client_fingerprint;
%{endif~}
}
%{endif~}

upstream armonik {
    zone armonik_zone 32k;
    server ${upstream} resolve;
    keepalive 128;
    keepalive_time 8h;
    keepalive_timeout 1h;
}

server {
%{if tls~}
    listen 8443 ssl http2;
    listen [::]:8443 ssl http2;
    listen 9443 ssl http2;
    listen [::]:9443 ssl http2;
    ssl_certificate     /ingress/ingress.crt;
    ssl_certificate_key /ingress/ingress.key;
%{if mtls~}
    ssl_verify_client on;
    ssl_client_certificate /ingressclient/ca.pem;
%{else~}
    ssl_verify_client off;
    proxy_hide_header X-Certificate-Client-CN;
    proxy_hide_header X-Certificate-Client-Fingerprint;
%{endif~}
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers EECDH+AESGCM:EECDH+AES256;
    ssl_conf_command Ciphersuites TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256;
%{else~}
    listen 8080;
    listen [::]:8080;
    listen 9080 http2;
    listen [::]:9080 http2;
%{endif~}

    sendfile on;
    tcp_nopush on;

    location = / {
        rewrite ^ $scheme://$http_host/admin/$accept_language/;
    }

    location = /admin {
        rewrite ^ $scheme://$http_host/admin/$accept_language/;
    }
    location = /admin/ {
        rewrite ^ $scheme://$http_host/admin/$accept_language/;
    }

%{for lang in try(coalesce(gui.langs), {})~}
    location = /admin/${lang} {
        rewrite ^ $scheme://$http_host/admin/${lang}/;
    }
%{endfor~}

%{if can(try(coalesce(gui.url)))~}
    set $admin_app_upstream ${gui.url};
    location /admin/ {
        proxy_pass $admin_app_upstream$uri$is_args$args;
    }
%{endif~}

    location ~* ^/armonik\. {
%{if mtls~}
%{if load_balancer}
        # Forward client identity
        grpc_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        grpc_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{else}
        grpc_set_header X-Certificate-Client-CN $client_cn ;
        grpc_set_header X-Certificate-Client-Fingerprint $client_fingerprint;
%{endif~}
%{endif~}

%{if length(nginx.cors.allowed_host) != 0~}
        add_header Access-Control-Allow-Origin ${nginx.cors.allowed_host} always;
        add_header Access-Control-Allow-Methods ${join(",", nginx.cors.allowed_methods)} always;
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin ${nginx.cors.allowed_host} always;
            add_header Access-Control-Allow-Methods ${join(",", nginx.cors.allowed_methods)};
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Headers' ${join(",", setunion(cors.default_grpc_headers, cors_all_headers))};
            add_header 'Access-Control-Max-Age' ${nginx.cors.preflight_max_age};
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }
%{endif~}
        grpc_pass grpc://armonik;

        # Apparently, multiple chunks in a grpc stream is counted has a single body
        # So disable the limit
        client_max_body_size 0;

        # add a timeout of 1 month to avoid grpc exception for long task
        # TODO: find better configuration
        client_body_timeout 1d;
        proxy_read_timeout 30d;
        proxy_send_timeout 1d;
        grpc_read_timeout 30d;
        grpc_send_timeout 1d;
    }

    location /static/ {
%{if length(nginx.cors.allowed_host) != 0~}
        add_header Access-Control-Allow-Origin ${nginx.cors.allowed_host} always;
        add_header Access-Control-Allow-Methods ${join(",", nginx.cors.allowed_methods)} always;
        if ($request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin ${nginx.cors.allowed_host} always;
            add_header Access-Control-Allow-Methods ${join(",", nginx.cors.allowed_methods)};
            add_header 'Access-Control-Allow-Credentials' 'true';
            add_header 'Access-Control-Allow-Headers' ${join(",", cors_all_headers)};
            add_header 'Access-Control-Max-Age' ${nginx.cors.preflight_max_age};
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }
%{endif~}
        alias /static/;
    }

    proxy_buffering off;
    proxy_request_buffering off;

%{for cluster_name, s3_urls in clusters_s3_urls~}
 set $minio_${cluster_name}_upstream ${clusters_s3_urls.service};
 location / {
    client_max_body_size 0;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    proxy_connect_timeout 300;
    # Default is HTTP/1, keepalive is only enabled in HTTP/1.1
    proxy_http_version 1.1;
    proxy_set_header Connection "";
    chunked_transfer_encoding off;

    proxy_pass $minio_${cluster_name}_upstream$uri$is_args$args; # This uses the upstream directive definition to load balance
 }

 set $minioconsole_${cluster_name}_upstream ${clusters_s3_urls.console};
 location /${cluster_name}/minioconsole {
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-NginX-Proxy true;

    rewrite ^/${cluster_name}/minioconsole/(.*) /$1 break;
    sub_filter '<head>' '<head><base href="$${scheme}://$${http_host}/${cluster_name}/minioconsole/">';
    sub_filter_once on;

    # This is necessary to pass the correct IP to be hashed
    real_ip_header X-Real-IP;

    proxy_connect_timeout 300;

    # To support websockets in MinIO versions released after January 2023
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    chunked_transfer_encoding off;

    proxy_pass $minioconsole_${cluster_name}_upstream$uri$is_args$args; # This uses the upstream directive definition to load balance and assumes a static Console port of 9001
 }
 %{endfor~}



%{for cluster_name, seq_url in clusters_seq_urls~}
    set $seq_${cluster_name}_upstream ${seq_url};
    location = /${cluster_name}/seq {
        rewrite ^ $scheme://$http_host/${cluster_name}/seq/ permanent;
    }
    location /${cluster_name}/seq/ {
%{if mtls~}
        proxy_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        proxy_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{endif~}
        proxy_set_header Host $http_host;
        proxy_set_header Accept-Encoding "";
        rewrite  ^/${cluster_name}/seq/(.*)  /$1 break;
        proxy_pass $seq_${cluster_name}_upstream$uri$is_args$args;
        sub_filter '<head>' '<head><base href="$${scheme}://$${http_host}/${cluster_name}/seq/">';
        sub_filter_once on;
        proxy_hide_header content-security-policy;
    }
%{endfor~}

%{for cluster_name, grafana_url in clusters_grafana_urls~}
    set $grafana_${cluster_name}_upstream ${grafana_url};
    location = /${cluster_name}/grafana {
        rewrite ^ $scheme://$http_host/${cluster_name}/grafana/ permanent;
    }
    location /${cluster_name}/grafana/ {
        rewrite  ^/${cluster_name}/grafana/(.*)  /$1 break;
%{if mtls~}
        proxy_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        proxy_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{endif~}
        proxy_set_header Host $http_host;
        proxy_pass $grafana_${cluster_name}_upstream$uri$is_args$args;
        sub_filter '<head>' '<head><base href="$${scheme}://$${http_host}/${cluster_name}/grafana/">';
        sub_filter_once on;
        proxy_intercept_errors on;
        error_page 301 302 307 =302 $${scheme}://$${http_host}$${upstream_http_location};
    }
    location /${cluster_name}/grafana/api/live {
        rewrite  ^/${cluster_name}/grafana/(.*)  /$1 break;
%{if mtls~}
        proxy_set_header X-Certificate-Client-CN $ssl_client_s_dn_cn;
        proxy_set_header X-Certificate-Client-Fingerprint $ssl_client_fingerprint;
%{endif~}
%{if tls~}
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
%{endif~}
        proxy_http_version 1.1;
        proxy_set_header Host $http_host;
        proxy_pass $grafana_${cluster_name}_upstream$uri$is_args$args;
    }
%{endfor~}

%{if can(try(coalesce(default_cluster)))~}
# Routes to default cluster
%{if length(clusters_seq_urls) > 0~}
    location = /seq {
        rewrite ^ $scheme://$http_host/${default_cluster}/seq/ permanent;
    }
    location /seq/ {
        rewrite ^ $scheme://$http_host/${default_cluster}/seq/ permanent;
    }
%{endif~}

%{if length(clusters_grafana_urls) > 0~}
    location = /grafana {
        rewrite ^ $scheme://$http_host/${default_cluster}/grafana/ permanent;
    }
    location /grafana/ {
        rewrite ^ $scheme://$http_host/${default_cluster}/grafana/ permanent;
    }
    location /grafana/api/live {
        rewrite ^ $scheme://$http_host/${default_cluster}/grafana/api/live permanent;
    }
%{endif~}
%{endif~}
}